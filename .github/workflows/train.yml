# .github/workflows/train.yml

name: MLOps Training Pipeline

on:
  # Запуск вручную для контроля, или по расписанию (schedule)
  workflow_dispatch:
    inputs:
      s3_bucket:
        description: 'S3 bucket for data/artifacts'
        required: true
        default: 'anomaly-mlops-mnist-data'
      epochs:
        description: 'Number of training epochs'
        required: false
        default: '1' # Устанавливаем 1 для быстрого теста
        
# --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ ---
env:
  # Используем входные данные или дефолтные значения
  S3_BUCKET_NAME: ${{ github.event.inputs.s3_bucket || 'anomaly-mlops-mnist-data' }}
  TRAINING_EPOCHS: ${{ github.event.inputs.epochs || '1' }}
  
  # Наш EC2 инстанс
  EC2_INSTANCE_NAME: MNIST-Anomaly-MLOps-Train-Worker
  
  # Никнейм для GHCR (если он отличается от github.actor)
  # Мы используем github.actor для простоты, но оставляем возможность замены
  GHCR_USERNAME: ${{ github.actor }} 

jobs:
  # 1. BUILD AND PUBLISH TRAINER IMAGE
  build_and_push_trainer:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read 
      packages: write 
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry (GHCR)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} 

      - name: Determine Docker Tag for Trainer
        id: meta_train
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.actor }}/mnist-anomaly-mlops-trainer 
          tags: |
            type=raw,value=latest
            type=sha,format=short

      - name: Build and Push Docker Image (Trainer)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.train 
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta_train.outputs.tags }}
          labels: ${{ steps.meta_train.outputs.labels }}

  # 2. TRIGGER REMOTE TRAINING AND PUBLISH MODEL
  
  train_and_publish:
    runs-on: ubuntu-latest
    #needs: [build_and_push_trainer] # Ждем успешной сборки
    
    # Настраиваем переменные окружения AWS
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Используем ключи, которые вы сохранили в Secrets
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Start EC2 Instance
        id: start_ec2
        run: |
          echo "Starting EC2 instance ${{ env.EC2_INSTANCE_NAME }}..."
          # Получаем ID инстанса по тегу Name
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${{ env.EC2_INSTANCE_NAME }}" --query "Reservations[].Instances[].InstanceId" --output text)
          
          # Запускаем инстанс
          aws ec2 start-instances --instance-ids "$INSTANCE_ID"
          
          echo "Waiting for EC2 instance to be ready (up to 30s)..."
          # Даем инстансу время на запуск и подключение к SSM
          sleep 30 

      - name: Run Training via AWS SSM
        id: run_ssm_command
        # Ключевой шаг: отправляем команду Docker на EC2
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${{ env.EC2_INSTANCE_NAME }}" --query "Reservations[].Instances[].InstanceId" --output text)
          
          # Формируем команду Docker с аргументами
          DOCKER_CMD="docker run --rm \
          ghcr.io/${{ env.GHCR_USERNAME }}/${{ github.event.repository.name }}-trainer:latest \
          --s3-bucket ${{ env.S3_BUCKET_NAME }} \
          --epochs ${{ env.TRAINING_EPOCHS }}"
          
          echo "Sending command: $DOCKER_CMD"
          
          # Отправляем команду через SSM
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="$DOCKER_CMD" \
            --comment "Run MLOps Training Pipeline" \
            --output text --query "Command.CommandId" > command_id.txt
            
          COMMAND_ID=$(cat command_id.txt)
          echo "Sent SSM command: $COMMAND_ID. Waiting for execution..."
          
          # Ждем завершения команды (макс. 20 минут)
          # --delay 15 --max-attempts 80 = 20 минут
          aws ssm wait command-executed --command-id $COMMAND_ID --instance-id $INSTANCE_ID --delay 15 --max-attempts 80

          echo "SSM command finished. Retrieving output..."
          # Получаем вывод команды (логи тренировки)
          aws ssm get-command-invocation --command-id $COMMAND_ID --instance-id $INSTANCE_ID --query "StandardOutputContent" --output text

      - name: Stop EC2 Instance
        if: always() # Останавливаем даже если тренировка провалилась (чтобы сэкономить деньги)
        run: |
          echo "Stopping EC2 instance..."
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${{ env.EC2_INSTANCE_NAME }}" --query "Reservations[].Instances[].InstanceId" --output text)
          aws ec2 stop-instances --instance-ids "$INSTANCE_ID"
          echo "EC2 instance stopped."